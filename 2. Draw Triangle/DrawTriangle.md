# TRIANGLE

---

## Step by step

- [Creating a VAO (Vertex Array Object)](#vertex-array-object)
- [Creating VBO (Vertex Buffer Object)](#vertex-buffer-object)
- [Shader](#shader)
    - [Shader Type](#shader-type)
        - [Vertex Shader](#vertex-shader)
        - [Fragment Shader](#fragment-shader)
- [Draw Triangle](#draw-triangle)

<b>Additional Notes</b>
- [Vertex](#vertex)
    - [Attribute Vertex](#vertex-attributes)
- [Buffer Object](#buffer-object)


# Vertex Array Object

> <b>VAO</b> is an object used to organize the vertex data format on the GPU.

Using VAO helps in managing and storing vertex configurations, making it easy to switch between multiple sets of vertex
data without the need to reconfigure each time.

```c++
Vertex vertices[] = {
        // Position - pos 0     Padding     Color - pos 1
        {{-0.5f, -0.5f, 0.0f},  0,          {1.0f, 0.0f, 0.0f}},
        {{ 0.5f, -0.5f, 0.0f},  0,          {0.0f, 1.0f, 0.0f}},
        {{ 0.0f,  0.5f, 0.0f},  0,          {0.0f, 0.0f, 1.0f}}
};

. . . 

glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *) offsetof(Vertex, position));
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *) offsetof(Vertex, color));

glEnableVertexAttribArray(0);
glEnableVertexAttribArray(1);
```

* In `glVertexAttribPointer`, we use it to set pointers to vertex attribute data within the VBO. This associates specific 
data (such as position, color, or texture coordinates) with the corresponding VBO.

* The `glEnableVertexAttribArray` is used to enable the vertex attributes that have been configured with
`glVertexAttribPointer1.

<details>
<summary><b>Creating VAO</b></summary>

```c++
GLuint VAO;

glGenVertexArrays(1, &VAO);
glBindVertexArray(VAO);
```

* Generate and obtains an ID for the VAO
* Bind the VAO to configure vertex data
</details>

# Vertex Buffer Object
VBO is used to store vertex attribute data such as position, color, texture coordinates, etc. This data is used by the
GPU to render objects.

> VBO makes it possible to send vertex data to the GPU once and store it there for repeated use.

This can reduce data transfer overhead between the CPU and GPU, which can significantly improve performance.

<details>
<summary><b>Creating VBO</b></summary>

```c++
GLuint VBO;

glGenBuffers(1, &VBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```

1. Generate VBO, Generate VBO to get an ID that will be used to refer to the VBO object.
2. Binding VBO with `GL_ARRAY_BUFFER` [Buffer Object](#buffer-object), Indicates that this VBO will be used to store vertex attribute data
such as position, color or texture coordinates.
3. Filling data into VBO, filling VBO with vertices data that has been created.
</details>


# Shader
Shaders are used to control how each pixel or vertex in an object is rendered or displayed on the screen. Shaders are
also used to change colors, textures, lighting and other visual effects in 3D graphics.

## Shader Type
### Vertex Shader
Vertex Shader operates at each point (vertex) of the object to be rendered. Vertex shaders are used to change the
position, color or other properties of each vertex before the object is rendered.

```glsl
#version 330 core

layout (location = 0) in vec3 Position;
layout (location = 1) in vec3 Color;

out vec3 outColor;

void main()
{
    gl_Position = vec4(Position, 1.0);
    outColor = Color;
}
```

* Vertex Shader will receive input in the form of position and color of each vertex.
* Then the Vertex Shader will also send color data (outColor) to the Fragment Shader.
* Ultimately, this Vertex Shader changes the vertex position (gl_Position) by converting it to coordinates in projection
space.

### Fragment Shader
Fragment Shader operates on each pixel that will be generated by an object that has been transformed by the vertex
shader. Fragment shaders are used to determine the color of each pixel on the screen based on interpolation of the
vertex shader results.

```glsl
#version 330 core

in vec3 outColor;

out vec4 FragmentColor;

void main()
{
    FragmentColor = vec4(outColor, 1.0);
}
```

* Fragment Shader receives color data (outColor) sent by Vertex Shader
* Then we use it to set the final color (FragmentColor) of the pixels on the screen.

# Draw Triangle
```c++
Vertex vertices[] = {
        // Position - pos 0     Padding     Color - pos 1
        {{-0.5f, -0.5f, 0.0f},  0,          {1.0f, 0.0f, 0.0f}},
        {{ 0.5f, -0.5f, 0.0f},  0,          {0.0f, 1.0f, 0.0f}},
        {{ 0.0f,  0.5f, 0.0f},  0,          {0.0f, 0.0f, 1.0f}}
};

. . .

glDrawArrays(GL_TRIANGLE, 0, 3);
```

Draw a triangle using `glDrawArrays` from the vertices data.

---

# Vertex

A vertex is a point in 3D space that is used to define the corners and shape of a 3D object. Vertices are the basic
components of 3D objects and are usually defined in terms of X Y Z coordinates in a 3D coordinate system.

## Vertex Attributes

Each vertex can have several attributes, such as position, color, texture coordinates, normal and other attributes. This
attribute is used to describe how the vertex will be displayed.

<table>
  <tr>
    <td align="center" colspan="3">Position</td>
    <td align="center" colspan="4">Color</td>
    <td rowspan="2">...</td>
  </tr>
    <td>X</td>
    <td>Y</td>
    <td>Z</td>
    <td>Red</td>
    <td>Green</td>
    <td>Blue</td>
    <td>Alpha</td>
</table>

<details>
<summary><b>Additional Padding</b></summary>

[Avoid Misaligned Vertex Data](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html#//apple_ref/doc/uid/TP40008793-CH107-SW7)

It is also possible to add padding between vertex attributes. This can be used to ensure that each data element in a
structure has an aligned address in memory, which can improve performance in some cases such as:
1. <b>Alignment</b>, Modern computers often require data to be at aligned addresses for better performance.
2. <b>Cache Efficiency</b>, Adding padding can increase cache efficiency. If you have multiple data elements in a single
block of memory, adding padding can ensure that these elements do not "compete" with each other for cache access,
improving memory access performance.
3. <b>Cross-Platform</b>, Compatibility Some platforms or programming languages may have certain requirements regarding
data processing, so adding padding can ensure code portability.

> <b>Disadvantage</b>
>
> Adding padding can also result in wasting memory.

<table>
  <tr>
    <td align="center" colspan="3">Position</td>
    <td align="center">Padding</td>
    <td align="center" colspan="4">Color</td>
    <td rowspan="2">...</td>
  </tr>
    <td>X</td>
    <td>Y</td>
    <td>Z</td>
    <td>Byte</td>
    <td>Red</td>
    <td>Green</td>
    <td>Blue</td>
    <td>Alpha</td>
</table>
</details>

# Buffer Object

Buffer Object is an object used to store data. Data stored in the object buffer can be used by the GPU for various
purposes, such as rendering, transform feedback and compute shaders.

> <b>GL_ARRAY_BUFFER</b>
>
> Used to store vertex attribute data, such as position, color and normal. This vertex data is used by the GPU for
> object rendering.

> <b>GL_ELEMENT_ARRAY_BUFFER</b>
>
> Used to store Index Buffer Object(IBO) for rendering. 

> <b>GL_UNIFORM_BUFFER</b>
>
> Used to store uniform data, such as constants used by shaders. This uniform data can be shared by all shaders used in
> a program.

> <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>
> 
> Used to store transform feedback data. This transform feedback data is data produced by the shader, such as the
> position and normal of vertices that have been transformed.

> <b>GL_ATOMIC_COUNTER_BUFFER</b>
> 
> Used to store atomic counter data. This atomic counter data can be used to calculate values simultaneously by several
> threads.

<h1></h1>

<pre align="center">
<a href="#triangle">BACK TO TOP</a>
</pre>
